<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pingwi's Home</title>
<style>
  :root{
    --bg1:#8ed6ff; --bg2:#e6f7ff; --ui:#0b1d2a;
    --accent:#ffb703; --accent2:#ff6392; --good:#5fd17a; --bad:#ff4c4c;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(#dff4ff,#ffffff)}
  .wrap{display:grid;place-items:center;min-height:100%;padding:12px;background:linear-gradient(180deg,var(--bg1),var(--bg2))}
  canvas{width:min(100vw,900px);height:calc(min(100vw,900px)*0.56);max-height:85vh;image-rendering:pixelated;border-radius:18px;background:transparent;box-shadow:0 10px 30px rgba(0,0,0,.2)}
  .hud{position:fixed;inset:auto 0 10px 0;display:flex;justify-content:center;pointer-events:none}
  .panel{pointer-events:auto;display:flex;gap:12px;align-items:center;justify-content:center;padding:10px 14px;border-radius:999px;background:rgba(255,255,255,.85);box-shadow:0 6px 18px rgba(0,0,0,.15);backdrop-filter:blur(6px)}
  .panel b{color:var(--ui)}
  .btn{cursor:pointer;border:none;border-radius:999px;padding:10px 16px;font-weight:700;background:linear-gradient(135deg,var(--accent),#ffd36a);color:#222;box-shadow:0 4px 0 #e39c00;transform:translateY(0);transition:.1s}
  .btn:active{transform:translateY(2px);box-shadow:0 2px 0 #e39c00}
  .overlay{position:fixed;inset:0;display:grid;place-items:center;background:rgba(11,29,42,.5);color:#fff;text-align:center;padding:24px}
  .card{background:linear-gradient(180deg,rgba(255,255,255,.95),rgba(255,255,255,.85));color:#111;border-radius:20px;padding:22px;max-width:560px;box-shadow:0 12px 30px rgba(0,0,0,.25)}
  .title{font-size:clamp(22px,4.2vw,38px);margin:0 0 8px;font-weight:900;color:#0b1d2a}
  .subtitle{margin:0 0 18px;color:#234}
  .keys{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin:12px 0}
  .key{border-radius:10px;padding:8px 12px;background:#eef6ff;border:2px solid #c8e4ff;color:#114;font-weight:700}
  .note{font-size:14px;color:#345}
  .pill{display:inline-block;padding:.2em .6em;border-radius:999px;background:#fff2c4;color:#7a4b00;font-weight:700}
  .win{color:var(--good);font-weight:900}
  .lose{color:var(--bad);font-weight:900}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="1280" height="720" aria-label="Pingwi's Home game canvas"></canvas>
</div>

<div class="hud" aria-live="polite">
  <div class="panel" id="hudPanel">
    <b>Score:</b>&nbsp;<span id="score">0</span>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <b>Best:</b>&nbsp;<span id="best">0</span>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <b>Speed:</b>&nbsp;<span id="speed">1.0x</span>
    &nbsp;&nbsp;|&nbsp;&nbsp;
    <b>Goal:</b>&nbsp;<span id="goal">‚Äî</span>
    <button class="btn" id="retryBtn" style="margin-left:10px">Retry</button>
  </div>
</div>

<div class="overlay" id="overlay">
  <div class="card">
    <h1 class="title">Pingwi's Home</h1>
    <p class="subtitle">Help <b>Pingwi</b> leap over chilly obstacles and reach his cozy igloo!<br>
      Survive, score big, and chase the <span class="pill">final destination</span>.</p>
    <div class="keys">
      <div class="key">Space</div><div class="key">‚Üë Arrow</div><div class="key">W</div><div class="key">Click / Tap</div><div class="key">R = Retry</div>
    </div>
    <p class="note">Jump to start. Sounds play after your first click/tap (browser safety).</p>
    <button class="btn" id="startBtn">Start Game</button>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const bestEl  = document.getElementById('best');
  const speedEl = document.getElementById('speed');
  const goalEl  = document.getElementById('goal');
  const overlay = document.getElementById('overlay');
  const startBtn= document.getElementById('startBtn');
  const retryBtn= document.getElementById('retryBtn');

  const BEST_KEY = 'pingwi_best_score_v1';
  let bestScore = Number(localStorage.getItem(BEST_KEY) || 0);
  bestEl.textContent = bestScore;

  // ---------- Audio ----------
  let audioCtx = null;
  const SFX = {
    jump: () => beep(440, 0.06, 0.2),
    land: () => beep(180, 0.03, 0.08),
    bonk: () => drum(0.15),
    score: () => beep(880, 0.05, 0.15),
    win: () => chord([523,659,784], 0.4),
  };
  function initAudio(){ if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
  function beep(freq=440, attack=0.02, release=0.2){
    if(!audioCtx) return;
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type='square'; o.frequency.value=freq; g.gain.value=0; o.connect(g); g.connect(audioCtx.destination);
    const t=audioCtx.currentTime;
    g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.3,t+attack);
    g.gain.exponentialRampToValueAtTime(0.0001,t+attack+release);
    o.start(t); o.stop(t+attack+release+0.02);
  }
  function drum(dur=0.12){
    if(!audioCtx) return;
    const b = audioCtx.createBuffer(1, audioCtx.sampleRate*dur, audioCtx.sampleRate);
    const data = b.getChannelData(0);
    for(let i=0;i<data.length;i++){ const t=i/data.length; data[i]=(Math.random()*2-1)*(1-t)*(1-t); }
    const s = audioCtx.createBufferSource(); s.buffer=b;
    const g = audioCtx.createGain(); g.gain.value=0.6; s.connect(g); g.connect(audioCtx.destination); s.start();
  }
  function chord(freqs=[440,550,660], release=0.4){
    if(!audioCtx) return;
    const g = audioCtx.createGain(); g.gain.value=0; g.connect(audioCtx.destination);
    const t=audioCtx.currentTime; g.gain.linearRampToValueAtTime(0.4,t+0.03); g.gain.exponentialRampToValueAtTime(0.0001,t+release);
    freqs.forEach(f=>{ const o=audioCtx.createOscillator(); o.type='triangle'; o.frequency.value=f; o.connect(g); o.start(t); o.stop(t+release+0.02); });
  }

  // ---------- Game constants ----------
  const WORLD = {
    gravity: 2100,
    groundY: 580,
    baseSpeed: 420,
    maxSpeed: 1050,
    accelPerSec: 28,
    jumpVel: 880,
    targetDistance: 1800, // survive until this score to spawn igloo
  };

  const layers = [
    { factor: 0.15, draw: drawSky },
    { factor: 0.25, draw: drawClouds },
    { factor: 0.45, draw: drawMounts },
    { factor: 0.8,  draw: drawIcebergs },
    { factor: 1.0,  draw: drawGround }
  ];

  const penguin = { x: 220, y: WORLD.groundY, w: 70, h: 78, vy: 0, onGround: true, tilt:0, flap:0, blink:0 };

  let obstacles = [];

  // Igloo now spawns after targetDistance and moves in-world at ground speed.
  const igloo = {
    active:false,
    x: 0, y: WORLD.groundY,
    w:170, h:120,
    door:{ w:52, h:40, offsetX:-26, offsetY:-20 } // relative to igloo origin (top-left when drawing base rect)
  };

  // Runtime
  let running=false, gameOver=false, youWin=false;
  let speed = WORLD.baseSpeed;
  let distance = 0;
  let spawnTimer = 0;
  let score = 0;

  function rnd(a,b){ return Math.random()*(b-a)+a; }

  function reset(){
    speed = WORLD.baseSpeed;
    distance = 0; spawnTimer = 0; score = 0;
    obstacles = [];
    penguin.y = WORLD.groundY; penguin.vy=0; penguin.onGround=true;
    penguin.tilt=0; penguin.flap=0; penguin.blink=0;
    Object.assign(igloo,{active:false,x:0,y:WORLD.groundY});
    gameOver=false; youWin=false;
    bestEl.textContent = bestScore;
    updateHUD();
  }

  function start(){
    initAudio();
    overlay.style.display='none';
    running = true; lastTime = performance.now();
    loop();
  }

  function end( win=false ){
    running = false; gameOver = !win; youWin = win;
    if(win){ SFX.win(); } else { SFX.bonk(); }
    const final = Math.floor(distance);
    if (final > bestScore){
      bestScore = final;
      localStorage.setItem(BEST_KEY,String(bestScore));
    }
    bestEl.textContent = bestScore;
    showOverlay(win ? 'üèÜ You reached the igloo!' : 'üí• Bonk! Pingwi slipped!');
  }

  function showOverlay(message){
    overlay.innerHTML = `
      <div class="card" role="dialog" aria-modal="true">
        <h1 class="title">Pingwi's Home</h1>
        <p class="subtitle">${gameOver ? `<span class="lose">${message}</span>` : youWin ? `<span class="win">${message}</span>` : message}</p>
        <p><b>Score:</b> ${Math.floor(distance)} &nbsp; | &nbsp; <b>Best:</b> ${bestScore}</p>
        <div class="keys"><div class="key">Space / Tap = Jump</div><div class="key">R = Retry</div></div>
        <button class="btn" id="ovrRestart">Play Again</button>
      </div>`;
    overlay.style.display='grid';
    document.getElementById('ovrRestart').onclick = () => { overlay.style.display='none'; reset(); start(); };
  }

  function updateHUD(){
    scoreEl.textContent = Math.floor(distance);
    bestEl.textContent  = bestScore;
    speedEl.textContent = (speed/WORLD.baseSpeed).toFixed(1)+'x';
    if (!igloo.active){
      const left = Math.max(0, Math.floor(WORLD.targetDistance - distance));
      goalEl.textContent = `${left}m`;
    } else {
      goalEl.textContent = 'Reach it!';
    }
  }

  // Input
  function jump(){
    if(gameOver||youWin) return;
    if (penguin.onGround){
      penguin.vy = -WORLD.jumpVel;
      penguin.onGround=false;
      penguin.flap = 1;
      SFX.jump();
    }
  }
  window.addEventListener('keydown', (e)=>{
    if([' ','ArrowUp','w','W'].includes(e.key)){ e.preventDefault(); jump(); }
    if(e.key==='r' || e.key==='R'){ reset(); start(); }
  });
  canvas.addEventListener('pointerdown', jump);
  startBtn.addEventListener('click', ()=>{ reset(); start(); });
  retryBtn.addEventListener('click', ()=>{ reset(); start(); });

  // Obstacles
  function spawnObstacle(){
    const type = Math.random()<0.75 ? 'ice' : 'snowman';
    const w = type==='ice' ? rnd(40,90) : 60;
    const h = type==='ice' ? rnd(40,90) : 100;
    const y = WORLD.groundY - h;
    obstacles.push({ x: canvas.width + rnd(0,80), y, w, h, type, passed:false });
  }

  function collide(a,b){
    return !(a.x+a.w<b.x || a.x>b.x+b.w || a.y+a.h<b.y || a.y>b.y+b.h);
  }

  // Main loop
  let lastTime = performance.now();
  function loop(now=performance.now()){
    if(!running) return;
    const dt = Math.min(1/30, (now-lastTime)/1000); lastTime = now;

    // Speed ramp + score
    speed = Math.min(WORLD.maxSpeed, speed + WORLD.accelPerSec*dt);
    distance += speed*dt*0.6;
    if (Math.floor(distance)%50===0) SFX.score();

    // Spawn igloo when target distance reached (once)
    if (!igloo.active && distance >= WORLD.targetDistance){
      igloo.active = true;
      igloo.x = canvas.width + 50; // start just off-screen right
      // optional: stop spawning more obstacles once igloo appears
      spawnTimer = Infinity;
    }

    // Spawn obstacles while igloo not present
    if (!igloo.active){
      spawnTimer -= dt;
      const spawnGap = Math.max(0.45, 1.1 - (speed-WORLD.baseSpeed)/800);
      if (spawnTimer <= 0){
        spawnObstacle();
        spawnTimer = spawnGap + rnd(-0.2,0.2);
      }
    }

    // Move obstacles
    for (let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      o.x -= speed*dt;
      if (!o.passed && o.x + o.w < penguin.x){ o.passed = true; score += 10; }
      if (o.x + o.w < -50) obstacles.splice(i,1);
    }

    // Move igloo if active
    if (igloo.active){
      igloo.x -= speed*dt; // same parallax as ground
      // Win when penguin reaches the igloo DOOR
      const door = {
        x: igloo.x + igloo.door.offsetX + igloo.w/2,
        y: igloo.y + igloo.door.offsetY,
        w: igloo.door.w,
        h: igloo.door.h
      };
      const pengBox = { x: penguin.x+8, y: penguin.y-penguin.h+10, w: penguin.w-16, h: penguin.h-12 };
      if (collide(pengBox, door)) { end(true); }
      // If igloo somehow goes past the penguin without collision (e.g., player jumped over door), still allow collision with full igloo to win
      const iglooBox = { x: igloo.x - igloo.w/2 + 85, y: igloo.y - 100, w: igloo.w, h: igloo.h };
      if (!youWin && collide(pengBox, iglooBox)) { end(true); }
      // Clean up if it moved off-screen left (missed) -> keep running (survival) or treat as fail? We'll let player continue; igloo won't respawn this run.
    }

    // Physics
    penguin.vy += WORLD.gravity*dt;
    penguin.y  += penguin.vy*dt;
    if (penguin.y >= WORLD.groundY){
      if(!penguin.onGround) SFX.land();
      penguin.y = WORLD.groundY; penguin.vy=0; penguin.onGround=true;
    }
    penguin.tilt = penguin.onGround ? 0 : Math.max(-0.35, Math.min(0.35, penguin.vy/1200));
    penguin.flap = Math.max(0, penguin.flap - dt*2);
    penguin.blink = (penguin.blink + dt) % 2.6;

    // Collisions with obstacles
    for (const o of obstacles){
      const box = {x:penguin.x+8, y:penguin.y-penguin.h+10, w:penguin.w-16, h:penguin.h-12};
      const obx = {x:o.x, y:o.y, w:o.w, h:o.h};
      if (collide(box, obx)){ end(false); }
    }

    // Draw
    ctx.clearRect(0,0,canvas.width,canvas.height);
    let scroll = distance;
    let groundOffset = scroll % canvas.width;
    layers.forEach(L => L.draw(L.factor * scroll, groundOffset));

    obstacles.forEach(o => drawObstacle(o));

    // Draw igloo if active (fixed scale, ‚Äúreal‚Äù object to reach)
    if (igloo.active) drawIglooAt(igloo.x, igloo.y);

    drawPenguin();

    updateHUD();
    requestAnimationFrame(loop);
  }

  // ---------- Drawing ----------
  function drawSky(){
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,'#8ed6ff'); g.addColorStop(1,'#e6f7ff');
    ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.beginPath(); ctx.arc(1100,100,60,0,Math.PI*2); ctx.fillStyle='#fff0a6'; ctx.fill();
  }
  function drawClouds(scroll){
    ctx.save(); ctx.globalAlpha=0.8;
    const speed = 0.25;
    for(let i=0;i<5;i++){
      const x = ( (i*300 - (scroll*speed)% (canvas.width+400)) % (canvas.width+400) ) - 200;
      drawCloud(x, 80 + (i%2)*40, 100 + i*7);
    }
    ctx.restore();
  }
  function drawCloud(x,y,w){
    ctx.fillStyle='#ffffff';
    ctx.beginPath();
    ctx.arc(x,y,w*0.3,0,Math.PI*2);
    ctx.arc(x+w*0.3,y-10,w*0.25,0,Math.PI*2);
    ctx.arc(x+w*0.6,y,w*0.35,0,Math.PI*2);
    ctx.fill();
  }
  function drawMounts(scroll){
    ctx.fillStyle='#cfe9ff';
    const baseY = 460;
    for(let i=0;i<6;i++){
      const x = ((i*280 - (scroll*0.45)%(canvas.width+300))%(canvas.width+300))-150;
      ctx.beginPath();
      ctx.moveTo(x, baseY); ctx.lineTo(x+120, baseY-130); ctx.lineTo(x+240, baseY); ctx.closePath(); ctx.fill();
      ctx.fillStyle='#ffffff';
      ctx.beginPath(); ctx.moveTo(x+120, baseY-130); ctx.lineTo(x+95, baseY-100); ctx.lineTo(x+145, baseY-100); ctx.closePath(); ctx.fill();
      ctx.fillStyle='#cfe9ff';
    }
  }
  function drawIcebergs(scroll){
    const y = WORLD.groundY-20;
    ctx.fillStyle='#dff6ff';
    for(let i=0;i<10;i++){
      const x = ((i*220 - (scroll*0.8)%(canvas.width+240))%(canvas.width+240))-120;
      ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+50,y-18); ctx.lineTo(x+100,y); ctx.closePath(); ctx.fill();
    }
  }
  function drawGround(){
    ctx.fillStyle='#f6fdff'; ctx.fillRect(0, WORLD.groundY, canvas.width, canvas.height - WORLD.groundY);
    ctx.fillStyle='#e3f4ff';
    for(let i=0;i<40;i++){
      ctx.beginPath();
      ctx.arc((i*33 + (performance.now()/30))%canvas.width, WORLD.groundY+20+ (i%5)*10, 3, 0, Math.PI*2);
      ctx.fill();
    }
  }
  function drawObstacle(o){
    if (o.type==='ice'){
      ctx.save(); ctx.translate(o.x, o.y);
      ctx.fillStyle='#b8e7ff'; roundRect(0,0,o.w,o.h,8,true,false);
      ctx.fillStyle='#e8f9ff'; ctx.fillRect(6,6,o.w-12,10);
      ctx.fillStyle='rgba(255,255,255,.35)'; ctx.beginPath(); ctx.moveTo(10,10); ctx.lineTo(o.w-14,10); ctx.lineTo(o.w-26,20); ctx.lineTo(18,20); ctx.closePath(); ctx.fill();
      ctx.restore();
    } else {
      ctx.save(); ctx.translate(o.x + o.w/2, o.y + o.h);
      ctx.fillStyle='#ffffff'; circle(0,-30,30); circle(0,-75,22);
      ctx.fillStyle='#222'; circle(-6,-82,2.4); circle(6,-82,2.4);
      ctx.fillStyle='#ff8c42'; triangle(4,-78, 28,-74, 4,-76);
      ctx.strokeStyle='#7a4b2b'; ctx.lineWidth=3; ctx.beginPath();
      ctx.moveTo(-18,-64); ctx.lineTo(-42,-78); ctx.moveTo(18,-64); ctx.lineTo(42,-78); ctx.stroke();
      ctx.restore();
    }
  }

  // NEW: fixed-size igloo renderer at (x,y)
  function drawIglooAt(x, y){
    ctx.save();
    // Base position aligns so that (x,y) is ground baseline at center-ish of igloo
    ctx.translate(x, y);
    ctx.translate(0, -40); // lift to sit on ground

    // main dome
    ctx.fillStyle='#e8f9ff';
    ctx.beginPath(); ctx.ellipse(0,0,90,60,0,0,Math.PI*2); ctx.fill();

    // bricks
    ctx.strokeStyle='#d0e9f7'; ctx.lineWidth=2;
    for(let r=-60;r<=20;r+=16){
      ctx.beginPath();
      const t = 1 - (r+60)/120;
      ctx.ellipse(0,r,90*t, 60*t, 0, 0, Math.PI*2); ctx.stroke();
    }

    // door (use same door dims for collision)
    ctx.fillStyle='#a7c8da';
    const doorX = igloo.door.offsetX + igloo.w/2;
    const doorY = igloo.door.offsetY + 40; // compensate translate
    roundRect(doorX, doorY, igloo.door.w, igloo.door.h, 12, true, false);

    ctx.restore();
  }

  function drawPenguin(){
    ctx.save();
    const px = penguin.x, py = penguin.y;
    ctx.translate(px, py);
    ctx.translate(0, -penguin.h/2);
    ctx.rotate(penguin.tilt);

    // shadow
    ctx.save(); ctx.globalAlpha=0.2; ctx.fillStyle='#000';
    ctx.beginPath(); ctx.ellipse(-5, penguin.h/2+6, 30, 8, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();

    // body
    ctx.fillStyle='#ffffff'; ctx.beginPath(); ctx.ellipse(0,10,26,34,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#0f1b2d'; ctx.beginPath(); ctx.ellipse(-2,5,30,38,0,0,Math.PI*2); ctx.fill();

    // wings
    const flap = Math.sin(performance.now()/100*(1+penguin.flap*2))*0.25 - 0.15;
    ctx.save(); ctx.rotate(flap); ctx.fillStyle='#0f1b2d'; ellipse(-24,12,12,20); ctx.restore();
    ctx.save(); ctx.rotate(-flap/2); ctx.fillStyle='#0f1b2d'; ellipse(24,12,12,20); ctx.restore();

    // feet
    ctx.fillStyle='#ffb703'; ellipse(-12, 36, 12, 6); ellipse(10, 36, 12, 6);

    // face
    ctx.fillStyle='#ffb703'; triangle(10,-10, 30,-6, 10,-4);
    const blink = penguin.blink<0.08 ? 0.1 : 1;
    ctx.fillStyle='#fff'; circle(-4,-16,5*blink); circle(8,-14,5*blink);
    ctx.fillStyle='#111'; circle(-3,-16,2*blink); circle(9,-14,2*blink);

    // scarf
    ctx.fillStyle='#ff6392'; roundRect(-26,-6,52,10,5,true,false);
    ctx.fillStyle='#ff8db1'; roundRect(8,-2,12,22,6,true,false);

    ctx.restore();
  }

  // primitives
  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }
  function ellipse(x,y,rx,ry){ ctx.beginPath(); ctx.ellipse(x,y,rx,ry,0,0,Math.PI*2); ctx.fill(); }
  function triangle(x1,y1,x2,y2,x3,y3){ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3); ctx.closePath(); ctx.fill(); }
  function roundRect(x,y,w,h,r,fill=true,stroke=false){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden && running){ running=false; showOverlay('Paused ‚Äî welcome back to the snow!'); }
  });

  reset();

})();
</script>
</body>
</html>
